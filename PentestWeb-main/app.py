from flask import Flask, render_template, request, make_response, redirect, url_for
import requests
import nmap
import ssl
import socket
import os
import json
import re
import base64
from datetime import datetime
from weasyprint import HTML
from urllib.parse import urlparse
from io import BytesIO
from PIL import Image
from werkzeug.utils import secure_filename
import subprocess
import sqlite3  # Ditambahkan kembali untuk membaca session.sqlite sqlmap

app = Flask(__name__)

# ✅ Cek apakah hostname bisa di-resolve
def is_host_resolvable(host):
    """
    Fungsi untuk mengecek apakah hostname dapat di-resolve ke alamat IP.
    Mengembalikan True jika bisa, False jika tidak.
    """
    try:
        socket.gethostbyname(host)
        return True
    except socket.error:
        return False

# ✅ Cek security headers
def check_security_headers(url):
    """
    Melakukan pengecekan header keamanan pada response HTTP dari URL target.
    Mengembalikan list header yang dicek beserta status ada/tidaknya.
    """
    headers_to_check = [
        "Strict-Transport-Security", "Content-Security-Policy",
        "X-Content-Type-Options", "X-Frame-Options",
        "X-XSS-Protection", "Referrer-Policy", "Permissions-Policy"
    ]
    results = []
    try:
        response = requests.get(url, timeout=10)
        for header in headers_to_check:
            if header in response.headers:
                results.append((header, response.headers[header], True))
            else:
                results.append((header, "Missing", False))
    except requests.exceptions.Timeout:
        results.append(("Error", "Connection timed out while checking headers", False))
    except requests.exceptions.RequestException as e:
        results.append(("Error", f"Request failed: {str(e)}", False))
    return results

# ✅ Cek informasi SSL certificate
def check_ssl_info(hostname, port=443):
    """
    Mengecek informasi sertifikat SSL dari hostname target.
    Mengembalikan info subjek, issuer, masa berlaku, dan status validitas SSL.
    """
    context = ssl.create_default_context()
    results = {}
    try:
        with socket.create_connection((hostname, port), timeout=10) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                subject = dict(x[0] for x in cert['subject'])
                issuer = dict(x[0] for x in cert['issuer'])
                valid_from = cert['notBefore']
                valid_to = cert['notAfter']
                # Cek validitas tanggal
                from datetime import datetime
                fmt = '%b %d %H:%M:%S %Y %Z'
                valid_from_dt = datetime.strptime(valid_from, fmt)
                valid_to_dt = datetime.strptime(valid_to, fmt)
                now = datetime.utcnow()
                is_valid = valid_from_dt <= now <= valid_to_dt
                results = {
                    "subject": subject.get('commonName', '-'),
                    "issuer": issuer.get('commonName', '-'),
                    "valid_from": valid_from,
                    "valid_to": valid_to,
                    "is_valid": is_valid
                }
    except Exception as e:
        results = {"error": str(e)}
    return results

# ✅ Scan port dengan Nmap + log hasil mentah ke konsol
def check_ports(host):
    """
    Melakukan pemindaian port pada host target menggunakan Nmap.
    Mengembalikan daftar port terbuka beserta service dan versinya.
    """
    nmap_path = r"C:\Program Files (x86)\Nmap"
    if nmap_path not in os.environ["PATH"]:
        os.environ["PATH"] += os.pathsep + nmap_path
    result = {}
    try:
        nm = nmap.PortScanner()
        print(f"[INFO] Menjalankan nmap scan pada host: {host}")
        scan_result = nm.scan(hosts=host, arguments="-p 1-100 -sV")  # Perkecil rentang port ke 1-100
        print("[DEBUG] Hasil mentah dari nmap.scan():")
        print(json.dumps(scan_result, indent=2))
        if 'scan' in scan_result and host in scan_result['scan']:
            hostdata = scan_result['scan'][host]
            for proto_name in ['tcp', 'udp']:
                proto = hostdata.get(proto_name, {})
                if proto:
                    result[proto_name] = []
                    for port, pdata in proto.items():
                        result[proto_name].append({
                            'port': int(port),
                            'state': pdata.get('state', '-'),
                            'service': pdata.get('name', '-'),
                            'product': pdata.get('product', '-'),
                            'version': pdata.get('version', '-')
                        })
        else:
            result['error'] = 'No scan result.'
    except Exception as e:
        result["error"] = str(e)
    return result

# ✅ Cek SQL Injection sederhana
def check_sql_injection(url):
    """
    Menjalankan sqlmap untuk mendeteksi kerentanan SQL Injection pada URL target.
    Mengembalikan status rentan/tidak dan detail hasil dari sqlmap.
    """
    # Jalankan sqlmap via subprocess
    try:
        # --batch agar non-interaktif, --level=1 cukup untuk test dasar
        cmd = [
            'python', r'C:\Users\wanda\OneDrive\Documents\PentestWeb-main - Copy - Copy\PentestWeb-main\sqlmap-dev\sqlmap.py',
            '-u', url,
            '--batch',
            '--level=1',
            '--risk=1',
            '--random-agent',
            '--answers=follow=N',
            '--disable-coloring',
            '--output-dir=output_sqlmap'
        ]
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        output = proc.stdout + proc.stderr
        # Cek hasil: cari "is vulnerable" atau "not injectable" atau error
        if 'is vulnerable' in output.lower() or 'sql injection vulnerability' in output.lower():
            return [(url, True, 'VULNERABLE: SQL Injection ditemukan oleh sqlmap')]
        elif 'all tested parameters do not appear to be injectable' in output.lower() or 'not injectable' in output.lower():
            return [(url, False, 'Tidak ditemukan SQL Injection oleh sqlmap')]
        else:
            # Jika tidak ada kerentanan, tampilkan pesan default yang lebih jelas
            detail = 'Tidak ditemukan parameter yang rentan atau tidak ada hasil payload dari sqlmap.'
            return [(url, False, f'Info: {detail}')]
    except Exception as e:
        return [(url, False, f'Error menjalankan sqlmap: {str(e)}')]

# ✅ Cek XSS sederhana
def check_xss(url):
    """
    Melakukan pengujian sederhana untuk mendeteksi Reflected XSS pada URL target.
    Mengirimkan beberapa payload XSS dan mengecek apakah payload muncul di response.
    """
    # Reflected XSS test (GET param)
    payloads = [
        '<script>alert(1)</script>',
        '"<img src=x onerror=alert(1)>',
        "'><svg/onload=alert(1)>"
    ]
    results = []
    for payload in payloads:
        # Inject to param 'xss' (add or append)
        if '?' in url:
            test_url = url + f'&xss={payload}'
        else:
            test_url = url + f'?xss={payload}'
        try:
            resp = requests.get(test_url, timeout=7)
            found = payload in resp.text
            results.append((payload, found))
        except Exception as e:
            results.append((payload, False))
    return results

# ✅ Cek LFI sederhana
def check_lfi(url):
    """
    Melakukan pengujian sederhana untuk mendeteksi Local File Inclusion (LFI) pada URL target.
    Mengirimkan payload file path dan mencari signature file pada response.
    """
    # LFI test (GET param)
    payloads = [
        '../../../../../etc/passwd',
        '..\\..\\..\\..\\windows\\win.ini',
        '/etc/passwd',
        'C:\\Windows\\win.ini'
    ]
    signatures = [
        'root:x:', # Linux passwd
        '[extensions]', # Windows ini
        '[fonts]',
        '[files]',
    ]
    results = []
    for payload in payloads:
        if '?' in url:
            test_url = url + f'&file={payload}'
        else:
            test_url = url + f'?file={payload}'
        try:
            resp = requests.get(test_url, timeout=7)
            found = False
            for sig in signatures:
                if sig in resp.text:
                    found = True
                    break
            results.append((payload, found))
        except Exception as e:
            results.append((payload, False))
    return results

# ✅ Cek Directory Traversal sederhana
def check_directory_traversal(url):
    """
    Melakukan pengujian sederhana untuk mendeteksi Directory Traversal pada URL target.
    Mengirimkan payload traversal dan mencari signature file pada response.
    """
    payloads = [
        '../../etc/passwd',
        '..\\..\\windows\\win.ini',
        '../boot.ini',
        '../../boot.ini',
        '../../../../../../etc/passwd',
    ]
    signatures = [
        'root:x:', 'boot loader', '[extensions]', '[fonts]', '[files]'
    ]
    results = []
    for payload in payloads:
        if '?' in url:
            test_url = url + f'&file={payload}'
        else:
            test_url = url + f'?file={payload}'
        try:
            resp = requests.get(test_url, timeout=7)
            found = any(sig in resp.text for sig in signatures)
            results.append((payload, found))
        except Exception:
            results.append((payload, False))
    return results

# ✅ Cek Open Redirect sederhana
def check_open_redirect(url):
    """
    Melakukan pengujian sederhana untuk mendeteksi Open Redirect pada URL target.
    Mengirimkan payload redirect dan mengecek apakah terjadi redirect ke domain berbahaya.
    """
    payloads = [
        'https://evil.com',
        '//evil.com',
        '/\\evil.com',
        '////evil.com',
    ]
    results = []
    for payload in payloads:
        if '?' in url:
            test_url = url + f'&redirect={payload}'
        else:
            test_url = url + f'?redirect={payload}'
        try:
            resp = requests.get(test_url, allow_redirects=False, timeout=7)
            location = resp.headers.get('Location', '')
            found = any(evil in location for evil in ['evil.com'])
            results.append((payload, found, location))
        except Exception:
            results.append((payload, False, 'Error'))
    return results

# ✅ Validasi format URL dan accessibility
def validate_url(url):
    errors = []
    
    # Cek format URL
    if not url:
        errors.append("URL tidak boleh kosong")
        return errors
        
    # Tambahkan https:// jika tidak ada
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url

    # Validasi format URL
    try:
        result = urlparse(url)
        if not all([result.scheme, result.netloc]):
            errors.append("Format URL tidak valid")
    except:
        errors.append("Format URL tidak valid")
        
    # Cek karakter khusus yang tidak diperbolehkan
    if re.search(r'[\s<>"{}|\\^`]+', url):
        errors.append("URL mengandung karakter yang tidak diperbolehkan")
    
    # Cek panjang URL
    if len(url) > 2048:
        errors.append("URL terlalu panjang (max 2048 karakter)")
        
    return errors

# ✅ Cek server/software technology
def check_server_software(url):
    try:
        resp = requests.get(url, timeout=10)
        server = resp.headers.get('Server', '-')
        powered = resp.headers.get('X-Powered-By', '-')
        tech = []
        if server and server != '-':
            tech.append(f"Server: {server}")
        if powered and powered != '-':
            tech.append(f"X-Powered-By: {powered}")
        # Tambahan: cari header teknologi lain
        for h in resp.headers:
            if h.lower().startswith('x-') and h.lower() not in ['x-powered-by']:
                tech.append(f"{h}: {resp.headers[h]}")
        return tech if tech else ['Tidak terdeteksi']
    except Exception as e:
        return [f"Error: {str(e)}"]

# ✅ Halaman utama
@app.route("/", methods=["GET", "POST"])
def index():
    headers_result = None
    ssl_result = None
    port_result = None
    sqlinj_result = None
    xss_result = None
    lfi_result = None
    dirtrav_result = None
    openredir_result = None
    url = None
    hostname = None
    errors = []
    server_software = None
    summary = None
    advanced_suggestions = []

    if request.method == "POST":
        url = request.form.get("url", "").strip()
        scan_headers = request.form.get("scan_headers")
        scan_ssl = request.form.get("scan_ssl")
        scan_ports = request.form.get("scan_ports")
        scan_sqli = request.form.get("scan_sqli")
        scan_xss = request.form.get("scan_xss")
        scan_lfi = request.form.get("scan_lfi")
        scan_dirtrav = request.form.get("scan_dirtrav")
        scan_openredir = request.form.get("scan_openredir")
        errors = validate_url(url)
        if not errors:
            # Normalisasi url
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            hostname = urlparse(url).netloc
            if scan_headers:
                headers_result = check_security_headers(url)
            if scan_ssl:
                ssl_result = check_ssl_info(hostname)
            if scan_ports and is_host_resolvable(hostname):
                port_result = check_ports(hostname)
            if scan_sqli:
                sqlinj_result = check_sql_injection(url)
            if scan_xss:
                xss_result = check_xss(url)
            if scan_lfi:
                lfi_result = check_lfi(url)
            if scan_dirtrav:
                dirtrav_result = check_directory_traversal(url)
            if scan_openredir:
                openredir_result = check_open_redirect(url)
            server_software = check_server_software(url)
            scan_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            summary = generate_summary(headers_result, ssl_result, port_result, sqlinj_result, xss_result, lfi_result, dirtrav_result, openredir_result, server_software, scan_time, url)
            if summary and 'risk_levels' in summary:
                advanced_suggestions = generate_advanced_suggestions(summary['risk_levels'])

    return render_template("index.html", 
                        url=url,
                        errors=errors,
                        headers=headers_result,
                        ssl=ssl_result,
                        ports=port_result,
                        sqlinj=sqlinj_result,
                        xss=xss_result,
                        lfi=lfi_result,
                        dirtrav=dirtrav_result,
                        openredir=openredir_result,
                        server_software=server_software,
                        summary=summary,
                        overall_risk=summary['overall_risk'] if summary else None,
                        risk_counts=summary['risk_counts'] if summary else None,
                        risk_levels=summary['risk_levels'] if summary else None,
                        scan_info=summary['scan_info'] if summary else None,
                        advanced_suggestions=advanced_suggestions)

def generate_summary(headers, ssl, ports, sqlinj, xss, lfi, dirtrav, openredir, server_software, scan_time=None, url=None):
    summary = {}
    # Risk ratings count
    risk_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Info': 0}
    risk_levels = []
    # Server info
    server_info = ', '.join(server_software) if server_software else '-'
    # Security headers
    if headers:
        missing = [h for h, v, valid in headers if not valid]
        if missing:
            risk_levels.append(('Security Headers', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('Security Headers', 'Low'))
            risk_counts['Low'] += 1
    # SSL
    if ssl and isinstance(ssl, dict):
        if ssl.get('is_valid'):
            risk_levels.append(('SSL', 'Low'))
            risk_counts['Low'] += 1
        else:
            risk_levels.append(('SSL', 'High'))
            risk_counts['High'] += 1
    # Ports
    if ports and isinstance(ports, dict) and not ports.get('error'):
        open_ports = sum([len(v) for v in ports.values() if isinstance(v, list)])
        if open_ports > 30:
            risk_levels.append(('Ports', 'High'))
            risk_counts['High'] += 1
        elif open_ports > 10:
            risk_levels.append(('Ports', 'Medium'))
            risk_counts['Medium'] += 1
        else:
            risk_levels.append(('Ports', 'Low'))
            risk_counts['Low'] += 1
    elif ports and ports.get('error'):
        risk_levels.append(('Ports', 'Info'))
        risk_counts['Info'] += 1
    # SQLi
    if sqlinj:
        if any(vuln for _, vuln, _ in sqlinj):
            risk_levels.append(('SQL Injection', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('SQL Injection', 'Low'))
            risk_counts['Low'] += 1
    # XSS
    if xss:
        if any(found for _, found in xss):
            risk_levels.append(('XSS', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('XSS', 'Low'))
            risk_counts['Low'] += 1
    # LFI
    if lfi:
        if any(found for _, found in lfi):
            risk_levels.append(('LFI', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('LFI', 'Low'))
            risk_counts['Low'] += 1
    # Directory Traversal
    if dirtrav:
        if any(found for _, found in dirtrav):
            risk_levels.append(('Directory Traversal', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('Directory Traversal', 'Low'))
            risk_counts['Low'] += 1
    # Open Redirect
    if openredir:
        if any(found for _, found, _ in openredir):
            risk_levels.append(('Open Redirect', 'High'))
            risk_counts['High'] += 1
        else:
            risk_levels.append(('Open Redirect', 'Low'))
            risk_counts['Low'] += 1
    # Overall risk
    if risk_counts['Critical'] > 0:
        overall = 'Critical'
    elif risk_counts['High'] > 0:
        overall = 'High'
    elif risk_counts['Medium'] > 0:
        overall = 'Medium'
    elif risk_counts['Low'] > 0:
        overall = 'Low'
    else:
        overall = 'Info'
    # Scan info
    scan_info = {
        'start_time': scan_time or '-',
        'finish_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'duration': '-',
        'tests_performed': len(risk_levels),
        'status': 'Finished'
    }
    summary['overall_risk'] = overall
    summary['risk_counts'] = risk_counts
    summary['risk_levels'] = risk_levels
    summary['scan_info'] = scan_info
    summary['server_info'] = server_info
    return summary

def generate_advanced_suggestions(risk_levels):
    suggestions = []
    for test, level in risk_levels:
        if test == 'Security Headers' and level == 'High':
            suggestions.append("Tambahkan header keamanan seperti Content-Security-Policy, HSTS, X-Frame-Options, Referrer-Policy, dsb.")
        if test == 'SSL' and level == 'High':
            suggestions.append("Pasang atau perbarui SSL certificate yang valid dan aktifkan HSTS.")
        if test == 'Ports' and level == 'High':
            suggestions.append("Tutup port yang tidak perlu, gunakan firewall, dan aktifkan monitoring akses port.")
        if test == 'SQL Injection' and level == 'High':
            suggestions.append("Gunakan parameterized query/prepared statement, validasi input, dan aktifkan WAF.")
        if test == 'XSS' and level == 'High':
            suggestions.append("Gunakan Content-Security-Policy, lakukan sanitasi dan validasi input/output.")
        if test == 'LFI' and level == 'High':
            suggestions.append("Validasi dan filter input file, gunakan allowlist path, dan matikan error detail di production.")
        if test == 'Directory Traversal' and level == 'High':
            suggestions.append("Validasi input path, gunakan fungsi file handler yang aman, dan batasi akses direktori.")
        if test == 'Open Redirect' and level == 'High':
            suggestions.append("Validasi dan allowlist URL redirect, jangan gunakan input user secara langsung untuk redirect.")
        # Saran untuk Medium
        if level == 'Medium':
            suggestions.append(f"Perbaiki konfigurasi pada bagian {test} untuk menurunkan risiko menjadi Low.")
        # Saran umum untuk Low
        if level == 'Low':
            suggestions.append(f"Bagian {test} sudah baik, tetap lakukan monitoring dan update berkala.")
    # Hilangkan duplikat
    return list(dict.fromkeys(suggestions))

# ✅ Ekspor hasil ke PDF
@app.route("/export-pdf", methods=["GET", "POST"])
def export_pdf():
    if request.method == "POST":
        url = request.form.get("url").strip()
    else:
        url = request.args.get("url", "").strip()
    if not url.startswith("http"):
        url = "https://" + url
    hostname = url.replace("https://", "").replace("http://", "").split("/")[0]

    headers_result = check_security_headers(url)
    ssl_result = check_ssl_info(hostname)
    if is_host_resolvable(hostname):
        port_result = check_ports(hostname)
    else:
        port_result = {"error": f"Hostname '{hostname}' tidak bisa di-resolve"}
    sqlinj_result = check_sql_injection(url)
    xss_result = check_xss(url)
    lfi_result = check_lfi(url)
    dirtrav_result = check_directory_traversal(url)
    openredir_result = check_open_redirect(url)
    server_software = check_server_software(url)
    scan_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    summary = generate_summary(headers_result, ssl_result, port_result, sqlinj_result, xss_result, lfi_result, dirtrav_result, openredir_result, server_software, scan_time, url)

    # Render template tanpa qr_code_base64
    html = render_template(
        "pdf_template.html",
        url=url,
        headers=headers_result,
        ssl=ssl_result,
        ports=port_result,
        sqlinj=sqlinj_result,
        xss=xss_result,
        lfi=lfi_result,
        dirtrav=dirtrav_result,
        openredir=openredir_result,
        server_software=server_software,
        summary=summary,
        scan_time=scan_time,
        overall_risk=summary['overall_risk'] if summary else None,
        risk_counts=summary['risk_counts'] if summary else None,
        risk_levels=summary['risk_levels'] if summary else None,
        scan_info=summary['scan_info'] if summary else None
    )

    pdf = HTML(string=html).write_pdf()
    response = make_response(pdf)
    response.headers["Content-Type"] = "application/pdf"
    response.headers["Content-Disposition"] = f"attachment; filename=report_{hostname}.pdf"
    return response

# Endpoint untuk mengambil hasil SQLmap dari session.sqlite
@app.route("/sqlmap-detail", methods=["GET"])
def sqlmap_detail():
    url = request.args.get("url", "").strip()
    if not url:
        return {"error": "URL tidak diberikan"}, 400
    hostname = url.replace("https://", "").replace("http://", "").split("/")[0]
    db_path = f"output_sqlmap/{hostname}/session.sqlite"
    if not os.path.exists(db_path):
        return {"error": "File session.sqlite tidak ditemukan untuk target ini."}, 404
    try:
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in c.fetchall()]
        result = {}
        for table in tables:
            c.execute(f"SELECT * FROM {table} LIMIT 20")
            rows = c.fetchall()
            columns = [desc[0] for desc in c.description]
            result[table] = {"columns": columns, "rows": rows}
        conn.close()
        return result
    except Exception as e:
        return {"error": str(e)}, 500

if __name__ == "__main__":
    # Jalankan Flask di host 0.0.0.0 agar bisa diakses dari jaringan lokal, port 5000
    app.run(host="0.0.0.0", port=5000, debug=True)
